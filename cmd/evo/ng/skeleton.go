package ng

import (
	"github.com/getevo/evo-ng"
	"github.com/getevo/evo-ng/lib/ds"
	"github.com/getevo/evo-ng/lib/file"
	"github.com/moznion/gowrtr/generator"
	"strings"
)

type Skeleton struct {
	App       string            `json:"app"`
	Version   Version           `json:"version"`
	Include   []string          `json:"include"`
	HotReload bool              `json:"hot_reload"`
	Debug     bool              `json:"debug"`
	Config    []string          `json:"config"`
	Replace   map[string]string `json:"replace"`
	Module    string            `json:"module"`
	Packages  map[string]*Package
}

func (s *Skeleton) GenContext() {
	var root = generator.NewRoot()
	var imports = []string{"github.com/getevo/evo-ng"}
	var context = generator.NewStruct("Context")
	context = context.AddField("Base", "*evo.Context")
	context = context.AddField("fiber", "*fiber.Ctx")
	var statements = []generator.Statement{
		generator.NewRawStatement("c.Base = request"),
		generator.NewRawStatement("c.fiber = request.Fiber()"),
	}
	for _, include := range skeleton.Include {
		var pkg = skeleton.GetPackage(include)
		var imp = false
		for _, comment := range pkg.Comments {
			var fields = strings.Fields(strings.TrimLeft(comment, "//"))

			if len(fields) == 4 && strings.ToLower(fields[1]) == "extend" && strings.ToLower(fields[3]) == "context" {

				for _, decl := range pkg.Structs {
					if decl.HasFunction(ContextInterface) {
						context = context.AddField(fields[2], pkg.Name+"."+decl.Name)
						imp = true
						statements = append(statements, generator.NewRawStatement("c."+fields[2]+".Extend(request)"))
					}
				}
			}
		}
		if imp {
			if pkg.IsLocal {
				imports = append(imports, skeleton.Module+"/"+include)
			} else {
				imports = append(imports, strings.Split(include, "@")[0])
			}
		}

	}
	imports = append(imports, "github.com/gofiber/fiber/v2", "github.com/getevo/evo-ng/websocket")

	root = root.AddStatements(
		generator.NewPackage("http"),
		generator.NewComment("GENERATED BY EVO-NG"),
		generator.NewImport(imports...),
		generator.NewNewline(),
		generator.NewComment("Context struct represents the Context which hold the HTTP request and response. It has methods and variables for the request query string, parameters, body, HTTP headers, and so on which can also extends."),
		context,
	)

	root = root.AddStatements(generator.NewNewline(),
		generator.NewCommentf("New create new type of struct"),
		generator.NewFunc(
			generator.NewFuncReceiver("c", "*Context"),
			generator.NewFuncSignature("New").AddReturnTypes("evo.ContextInterface"),
			generator.NewReturnStatement("&Context{}"),
		))

	root = root.AddStatements(
		generator.NewNewline(),
		generator.NewCommentf("%s Wrap context ws/wss %s requests. callback accepts func(*http.Context,*websocket.Conn)", "WebSocket", "WebSocket"),
		generator.NewFunc(
			generator.NewFuncReceiver("c", "*Context"),
			generator.NewFuncSignature("WebSocket").AddParameters(
				generator.NewFuncParameter("request ", "*evo.Context"),
				generator.NewFuncParameter("callback", "interface{}"),
				generator.NewFuncParameter("ws", "*websocket.Conn"),
			).AddReturnTypes("err error"),
			append(statements, generator.NewReturnStatement("callback.(func(*Context,*websocket.Conn) error)(c,ws)"))...,
		),

		generator.NewNewline(),
		generator.NewCommentf("%s Matches http %s requests. callback accepts func(*http.Context)", "WebSocket", "WebSocket"),
		generator.NewFunc(
			nil,
			generator.NewFuncSignature("WebSocket").AddParameters(
				generator.NewFuncParameter("url ", "string"),
				generator.NewFuncParameter("callback", "func(*Context,*websocket.Conn) error"),
				generator.NewFuncParameter("params...", "interface{}"),
			),
			generator.NewRawStatement("evo."+"WebSocket"+("(url,callback,params...)")),
		),
	)
	var commonStatements = append(statements, generator.NewReturnStatement("callback.(func(*Context) error)(c)"))
	for _, method := range []string{"Get", "Post", "All", "Put", "Patch", "Options", "Connect", "Head", "Delete", "Use"} {
		/*		if method == "WebSocket" {
				var wsStatements = append(statements, generator.NewReturnStatement("callback.(func(*Context,*websocket.Conn) error)(c,ws)"))
				root = root.AddStatements(
					generator.NewNewline(),
					generator.NewCommentf("%s Wrap context ws/wss %s requests. callback accepts func(*http.Context,*websocket.Conn)", method, method),
					generator.NewFunc(
						generator.NewFuncReceiver("c", "*Context"),
						generator.NewFuncSignature(method).AddParameters(
							generator.NewFuncParameter("request ", "*evo.Context"),
							generator.NewFuncParameter("callback", "interface{}"),
							generator.NewFuncParameter("ws", "*websocket.Conn"),
						).AddReturnTypes("err error"),
						wsStatements...,
					),

					generator.NewNewline(),
					generator.NewCommentf("%s Matches http %s requests. callback accepts func(*http.Context)", method, method),
					generator.NewFunc(
						nil,
						generator.NewFuncSignature(method).AddParameters(
							generator.NewFuncParameter("url ", "string"),
							generator.NewFuncParameter("callback", "func(*Context,*websocket.Conn) error"),
							generator.NewFuncParameter("params...", "interface{}"),
						),
						generator.NewRawStatement("evo."+method+("(url,callback,params...)")),
					),
				)
				continue
			}*/

		root = root.AddStatements(
			generator.NewNewline(),
			generator.NewCommentf("%s Wrap context http %s requests. callback accepts func(*http.Context)", method, method),
			generator.NewFunc(
				generator.NewFuncReceiver("c", "*Context"),
				generator.NewFuncSignature(method).AddParameters(
					generator.NewFuncParameter("request ", "*evo.Context"),
					generator.NewFuncParameter("callback", "interface{}"),
				).AddReturnTypes("err error"),

				commonStatements...,
			),

			generator.NewNewline(),
			generator.NewCommentf("%s Matches http %s requests. callback accepts func(*http.Context)", method, method),
			generator.NewFunc(
				nil,
				generator.NewFuncSignature(method).AddParameters(
					generator.NewFuncParameter("url ", "string"),
					generator.NewFuncParameter("callback", "func(*Context) error"),
					generator.NewFuncParameter("params...", "interface{}"),
				),
				generator.NewRawStatement("evo."+method+("(url,callback,params...)")),
			),

			generator.NewNewline(),
			generator.NewCommentf("%s Matches http %s requests. callback accepts func(*http.Context)", method, method),
			generator.NewFunc(
				generator.NewFuncReceiver("r", "*Router"),
				generator.NewFuncSignature(method).AddParameters(
					generator.NewFuncParameter("url ", "string"),
					generator.NewFuncParameter("callback", "func(*Context) error"),
					generator.NewFuncParameter("params...", "interface{}"),
				),
				generator.NewRawStatement("evo."+method+(`(r.Prefix+url,callback,params...)`)),
			),
		)

	}

	root = root.AddStatements(
		generator.NewNewline(),
		generator.NewCommentf("%s create url to asset dir.", "Asset", "Asset"),
		generator.NewFunc(
			nil,
			generator.NewFuncSignature("Asset").AddParameters(
				generator.NewFuncParameter("url", "string"),
				generator.NewFuncParameter("localPath", "string"),
				generator.NewFuncParameter("params...", "evo.AssetConfig"),
			),
			generator.NewRawStatement("evo."+"Asset"+("(url,localPath,params...)")),
		),
	)

	generated, err := root.Generate(0)
	if err != nil {
		evo.Panic(err)
	}

	file.MakePath(file.WorkingDir() + "/http")
	file.Remove(file.WorkingDir() + "/http/context.go")
	file.Write(file.WorkingDir()+"/http/context.go", generated)

	if !file.IsFileExist(file.WorkingDir() + "/http/context.extend.go") {
		file.Write(file.WorkingDir()+"/http/context.extend.go", "package http \r\n//Project Extended Context\r\n")
	}
	if !file.IsFileExist(file.WorkingDir() + "/vendor/github.com/getevo/evo-ng/context.go") {
		run("go", "mod", "vendor")
	}
	b, err := file.ReadFile(file.WorkingDir() + "/vendor/github.com/getevo/evo-ng/context.go")
	if err != nil {
		evo.Panic(err)
	}
	file.Remove(file.WorkingDir() + "/http/context.fn.go")
	file.Write(file.WorkingDir()+"/http/context.fn.go", strings.Replace(string(b), "package evo", "package http", 1))
}

func (s *Skeleton) GetPackage(path string) *Package {
	if _, ok := s.Packages[path]; !ok {
		s.Packages[path] = ParsePackage(path)
	}
	return s.Packages[path]

}

type Version struct {
	Major int    `json:"major"`
	Minor int    `json:"minor"`
	Build int    `json:"build"`
	Hash  string `json:"hash"`
	Date  string `json:"date"`
}

type Include struct {
	Repo   *string `json:"repo,omitempty"`
	Branch *string `json:"branch,omitempty"`
	Local  *string `json:"local,omitempty"`
}

type Main struct {
	Root             *generator.Root
	ContextInterface Function
	Main             *generator.Func
	Events           ds.OrderedMap
}
